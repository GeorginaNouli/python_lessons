
### Άσκηση 1
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Θα επιστρέφει το άθροισμά τους. Η συνάρτηση πρέπει να ελέγχει αν η είσοδος είναι int ή float. Αν η είσοδος δεν είναι int ή float θα τυπώνει ένα μήνυμα λάθους.

### Άσκηση 2
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παραμέτρους. Θα επιστρέφει τους αριθμούς αυτούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο. Μην χρησιμοποιήσετε min. Επίσης η συνάρτηση θα ελέγχει αν οι παράμετροι είναι int ή float. Αν κάποια παράμετρος δεν είναι int ή float, θα τυπώνει μήνυμα λάθους

### Άσκηση 3
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παραμέτρους. Θα επιστρέφει το ζευγάρι αριθμών που έχει τη μικρότερη απόσταση. Ως απόσταση ορίζεται το απόλυτο της διαφοράς τους. Για παράδειγμα: οι 2 αριθμοί που έχουν την μικρότερη απόσταση από τους 1,7,3 είναι το 1 και το 3. Όπως και στις ασκήσεις 1 και 2 θα πρέπει να ελέγχει ότι οι αριθμοί είναι int ή float.

### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει ως είσοδο μία ακολουθεία νουκλεοτιδίων. Π.χ. μία είσοδος είναι η 'AAACGTTCGGAA'. Η συνάρτηση θα πρέπει να επιστρέφει True αν η ακολουθεία ΔΕΝ περιέχει άλλο γράμμα πέρα από τα 'A', 'C', 'G', 'T'. Για παράδειγμα αν η είσοδος είναι 'ACCGGFT', τότε επιστρέφει False. Αν η ακολουθεία είναι η 'ACCCAA', τότε επιστρέφει True. Αν η ακολουθεία είναι κενή τότε πρέπει να επιστρέφει False.

### Άσκηση 5
Το ίδιο με την Άσκηση 4 αλλά θα πρέπει να ελέγχει και αν το μήκος της ακολουθίας διαιρείται με το 3. Για παράδειγμα:
```
ACCCTA --> True
ACCFTT --> False (Δεν είναι όλα τα γράμματα A,C,G,T)
ACCCT  --> False (Δεν διαιρείται με το 3 το μήκος της)
ACCCF  --> False (Δεν διαιρείται με το 3 το μήκος της και έχει ένα γράμμα που δεν είναι A,C,G,T)
```

### Άσκηση 6
Από όλα τα ζευγάρια ακέραιων αριθμών α,β όπου 0<=α<=100 και 0<=β<=100 ποιοι είναι αυτοί για τους οποίους ισχύει:
```
(α+β)^2 = α*10 + β
```

### Άσκηση 7
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα αλφαριθμητικό (string), και θα επιστρέφει έναν ακέραιο που θα αποτελείται από όλα τα ψηφία του αλφαριθμητικού. Για παράδειγμα:
```
"καλη2μέ3ρα" --> 23
"1Ηρά3κλειο9" --> 139
```

### Άσκηση 8
Γράψτε μία συνάρτηση η οποία θα παίρνει 3 αριθμούς από 1 μέχρι το 10. Αρχικά θα ελέγχει αν και οι τρεις είναι διαφορετικοί μεταξύ τους. Αν δεν είναι, θα πετάει ένα μήνυμα λάθους και θα επιστρέφει None. Επίσης θα ελέγχει αν και οι τρεις είναι από το 1 μέχρι το 10 αλλιώς πάλι θα πετάει μήνυμα λάθους. Στη συνέχεια θα επιστρέφει ένα string με μέγεθος 10. Το string αυτό θα έχει τον χαρακτήρα αστεράκι (\*) σε όλες τις θέσεις εκτός από τις θέσεις με αριθμό κάποιον από τα ορίσματα. Σε αυτή τη θέση θα έχει τον αντίστοιχο αριθμό. Παραδείγματα:
```
5,1,9 --> '1***5***9*'
0,1,9 --> ΛΑΘΟΣ, ΟΛΟΙ ΟΙ ΑΡΙΘΜΟΙ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ ΑΠΟ ΤΟ 1 ΜΕΧΡΙ ΤΟ 10
5,1,5 --> ΛΑΘΟΣ, ΟΛΟΙ ΟΙ ΑΡΙΘΜΟΙ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ ΔΙΑΦΟΡΕΤΙΚΟΙ ΜΕΤΑΞΥ ΤΟΥΣ
5,6,8 --> '****56*8**'
```

### Άσκηση 9
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα ακέραιο αριθμό. Αν ο αριθμός είναι μικρότερος από το 100 θα επιστρέφει None και θα τυπώνει ένα μήνυμα λάθους. Διαφορετικά θα επιστρέφει True αν το άθροισμα των δύο πρώτων ψηφίων του είναι άρτιος (ζυγός) ή False αν δεν είναι. Παραδείγματα:
```
48973 --> True (4+8=12, άρτιος)
381 --> False (3+8=11, μονός)
3 --> ΛΑΘΟΣ, Ο ΑΡΙΘΜΟΣ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ ΜΕΓΑΛΥΤΕΡΟΣ ΑΠΟ ΤΟ 100
```

### Άσκηση 10
Μία μέρα έχει 24 ώρες. Μία ώρα έχει 60 λεπτά. Άρα μία μέρα έχει 24\*60=1440 λεπτά. Φτιάξτε μία συνάρτηση που να παίρνει σαν είσοδο έναν αριθμό από το 0 μέχρι και το 1440. Θα πρέπει να επιστρέφει δύο αριθμούς. Ο πρώτος θα είναι η γωνία του ωροδείκτη και ο δεύτερος η γωνία του λεπτοδείκτη, όταν έχουν περάσει τόσα λεπτά από τις 00:00 αυτής της μέρας, όσα η παράμετρος της συνάρτησης. Κάθε γωνία πρέπει να είναι ένας αριθμός από το 0 μέχρι το 360. 0 μοίρες είναι όταν ένας δείκτης είναι στο "12" του ρολογιού, 90 μοίρες είναι όταν είναι στο "3", 180 μοίρες είναι όταν ο δείκτης είναι στο "6" του ρολογιού, 270 μοίρες είναι όταν είναι στο 9. Μερικά παραδείγματα:
```
ΛΕΠΤΑ --> ΩΡΟΔΕΙΚΤΗΣ, ΛΕΠΤΟΔΕΙΚΤΗΣ
0 --> 0.0, 0.0
5 --> 2.5, 30.0
180 --> 90.0, 0.0
681 --> 340.5, 126.0
1000 --> 140.0, 240.0
```

### Άσκηση 11
Αν μία μπάλα χάνει το 7% του ύψους της κάθε φορά που αναπηδάει και την αφήσουμε να πέσει από το 1 μέτρο, μετά από πόσες αναπηδήσεις θα έχει φτάσει σε ύψος κάτω από το μισό μέτρο; Φτάξτε κώδικα python που απαντάει σε αυτό το ερώτημα με επαναληπτικό τρόπο (αν θέλετε κάντε το και με αναλυτικό). 

### Άσκηση 12
Βρείτε όλες τις λύσεις της εξίσωσης: ``` x^2 = y! + 1 ``` για 1<=x<=100 και 1<=y<=100. Όπου x και y είναι ακέραιοι.

### Άσκηση 13
Υπάρχουν μερικοί αριθμοί που μπορούν να γραφούν σαν άθροισμα δύο κύβων. Για παράδειγμα το 468 μπορεί να γραφεί σαν 5^3 + 7^3. Υπάρχει όμως μόνο δύο αριθμοί μικρότεροι από το 10.000, οι οποίοι μπορούν να γραφτούν με δύο τρόπους σαν άθροισμα δύο κύβων! Ο ένας από αυτούς είναι το 1729 επειδή: ``` 1729 = 1^3 + 12^3 και 1729 = 9^3 + 10^3 ```. Ποιος είναι ο δεύτερος αριθμός που έχει αυτή την ιδιότητα; Σημείωση: ψάχνουμε μόνο αριθμούς < 10.000 .

### Άσκηση 14
Ας υποθέσουμε ότι έχουμε ένα string (αλφαριθμητικό) το οποίο αποτελείται μόνο από '+' και '-'. Για παράδειγμα ```+----+++--```. Υποθέτουμε ότι το '+' αναπαριστά ένα πρωτόνιο και το '-' ένα αντι-πρωτόνιο! Όταν ένα πρωτόνιο ('+') και ένα αντι-πρωτόνιο ('-') είναι δίπλα-δίπλα τότε αυτά εξαφανίζονται! Για παράδειγμα παρακάτω έχω σημείωσει τις θέσεις όπου υπάρχουν '+' και '-' δίπλα-δίπλα (τις σημείωνω με ^).
```
+----+++--
^^  ^^ ^^
``` 

Αν εξαφανίσοθμε λοιπόν τις θέσεις που τα + και - είναι δίπλα-δίπλα, το string θα γίνει:
```
--+-
```

Και πάλι όμως βλέπουμε ότι το νέο string έχει '+' και '-' δίπλα-δίπλα. Οπότε αυτές οι θέσεις θα εξαφανιστούν και θα γίνει:
```
--
```

Τώρα παρατηρούμε ότι αφού έχει μόνο '-', το string δεν μπορεί να μικρύνει άλλο.

Φτιάξτε μία συνάρτηση που να παίρνει ένα string και θα ελέγχει αν έχει μόνο + και -. Στη συνέχεια πρέπει να επιστρέφει το string το οποίο ΔΕΝ μπορεί να μικρύνει άλλο. Δίνονται μερικά παραδείγματα:

```
+++---++-++--+--++-----++++-++-+++++--++-+---+----++++-+-++----+--+++-++--+-+-+++--+++--+++++++-+-++    ==>   ++++++++++++
+-+---++------+++-++++-+-+--+--+++--------++++--++---+----+---+++---++--++-++-+-++--+-+-++--++-+++--    ==>   --------
+--+--+++---+----+++--+-+--+--+-+----+++-++--+--+--+++++-+--+-+----++--+++-----+++-+++-++-+-++-++-+-    ==>   ----
```

### Άσκηση 19
Εδώ βλέπετε μία μαθηματική φόρμουλα για τον υπολογισμό του π. 
![img](https://pbs.twimg.com/media/D_Hq5UlWwAQ7CfL?format=jpg&name=large) 

Φτιάξτε μία συνάρτηση η οποία να παίρνει έναν ακέραιο αριθμό μεγαλύτερο ή ίσο με το 1. Στη συνέχεια θα επιστρέφει την προσέγγιση του π μέσω της παραπάνω φόρμουλας χρησιμοποιώντας τόσους παράγοντες όσους και η τιμή της παραμέτρου της συνάρτησης. Για παράδειγμα:
```
1 --> 2 
2 --> 2.82842712474619  (2 *  2/sqrt(2) )
3 --> 3.061467458920718 (2 *  2/sqrt(2) * 2/(sqrt(2+sqrt(2))) )
```

Υπολογισμός της τετραγωνικής ρίζας:
```python
import math

math.sqrt(16) # Τυπώνει 4
```

Σημείωση: Η φόρμουλα ανακαλύφτηκε από τον François Viète τον 16ο αιώνα.


### Άσκηση 20
Ένας αριθμός είναι πρώτος όταν διαρείται μόνο με το 1 και με τον εαυτό του. Υπάρχει μόνο ένας πρώτος αριθμός ο οποίος να είναι από το 10.000.000 μέχρι το 100.000.000 ο οποίος να έχει τη παρακάτω περίεργη ιδιότητα: Αν του "κόψεις" έναν οποιοδήποτε αριθμό από ψηφία από τα τέλος, αυτό που μένει να είναι πάντα πρώτος! Ποιος αριθμός είναι αυτός; Για παράδειγμα έστω ότι ο αριθμός που ψάχνουμε είναι ο 12.345.678 (spoiler alert, δεν είναι αυτός). Τότε θα πρέπει όλοι οι παρακάτω αριθμοί να είναι επίσης πρώτοι:
```
12345678
1234567
123456
12345
1234
123
12
1
```

